(* 
    uses pwb/workbench
*)

structure PiInstanceRequirements =
struct
  type name          = string
  type term          = name
  datatype condition = Eq of term * term | T | F
  datatype assertion = Unit

  type atom = name

  fun chaneq  (a,b)            = Eq (a,b)
  fun brReceive  (m,n)         = Eq (m,n)
  fun brTransmit (m,n)         = Eq (m,n)
  fun compose (psi1,psi2)      = Unit
  val unit                     = Unit
  fun entails (Unit,Eq (m, n)) = (m = n)
    | entails (Unit,T)         = true
    | entails (Unit,F)         = false

  fun swap_name (a,b) n = StringName.swap_name (a,b) n

  fun newBasedOn _ xvec = StringName.generateDistinct xvec
  fun new xvec = newBasedOn "a" xvec

  fun supportT n           = [n]
  fun supportC (Eq (a, b)) = [a, b]
    | supportC  _          = []
  fun supportA _           = []

  fun swapT pi n = swap_name pi n
  fun swapC _  F = F
    | swapC _  T = T
    | swapC pi (Eq (t1, t2)) =
        Eq (swap_name pi t1, swap_name pi t2)
  fun swapA _ _  = Unit

  fun eqT _ (a,b) = a = b
  fun eqC _ (a,b) = a = b
  fun eqA _ (a,b) = a = b

  fun substT sigma n =
    case List.find (fn (x,_) => x = n) sigma of
           NONE       => n
         | SOME (_,t) => t
  fun substC sigma F             = F
    | substC sigma T             = T
    | substC sigma (Eq (t1, t2)) =
        Eq (substT sigma t1, substT sigma t2)
  fun substA sigma Unit          = Unit


  (* the pi-calculus is unsorted *)
  structure Sort = Unsorted

  fun isNameSort _ = true
  fun canRecv _ _  = true
  fun canSend _ _  = true
  fun canSubs _ _  = true
  fun canRstr _    = true
  fun nameSort _   = Unsorted.SORT
  fun sortT _      = Unsorted.SORT
  fun sortC _      = Unsorted.SORT
  fun sortA _      = Unsorted.SORT

  structure Term = Nominal(struct
    structure AtomSort = Sort
    structure DataSort = Sort
    type atom    = name
    type data    = term
    val atomSort = nameSort
    val dataSort = sortT
    val swap     = swapT
    val support  = supportT
    val eq       = eqT
    val new      = new
    val newBasedOn = newBasedOn
  end)

  structure Cond = Nominal(struct
    structure AtomSort = Sort
    structure DataSort = Sort
    type atom    = name
    type data    = condition
    val atomSort = nameSort
    val dataSort = sortC
    val swap     = swapC
    val support  = supportC
    val eq       = eqC
    val new      = new
    val newBasedOn = newBasedOn
  end)

  structure Assr = Nominal(struct
    structure AtomSort = Sort
    structure DataSort = Sort
    type atom    = name
    type data    = assertion
    val atomSort = nameSort
    val dataSort = sortA
    val swap     = swapA
    val support  = supportA
    val eq       = eqA
    val new      = new
    val newBasedOn = newBasedOn
  end)

  fun isWellFormedOutSubj _ = Err.undefined "Pi.isWellFormedOutSubj"
  fun isWellFormedInSubj  _ = Err.undefined "Pi.isWellFormedInSubj "
  fun isWellFormedInvArg  _ = Err.undefined "Pi.isWellFormedInvArg "
  fun isWellFormedOutObj  _ = Err.undefined "Pi.isWellFormedOutObj "
  fun isWellFormedCond    _ = Err.undefined "Pi.isWellFormedCond   "
  fun isWellFormedAssr    _ = Err.undefined "Pi.isWellFormedAssr   "
end;

structure PsiPiInstance = Psi(PiInstanceRequirements)


structure PiSymbolicInstanceRequirements =
struct

  open PiInstanceRequirements

  fun var x = x

  structure Constraint = SymbolicOSConstraint(PsiPiInstance.Inst)


  fun dom sigma = map (fn (n,t) => n) sigma

  fun composeSubst sigma (s as (x',l')) =
  let
    val app = map (fn (n,t) => (n, substT [s] t)) sigma
  in
    if Lst.member x' (dom sigma)
      then app
      else s :: app
  end

  structure L = NominalNameList(PsiPiInstance.Inst.Term)

  fun mgu [] sigma = Either.RIGHT sigma                
    | mgu ((avec, Unit,  T::phis )::cs) sigma =        
      mgu ((avec, Unit,  phis )::cs) sigma
    | mgu ((avec, Unit,  [] )::cs) sigma =             
      mgu cs sigma
    | mgu ((avec, Unit, (Eq (a,b))::phis)::cs) sigma =
      if a = b                                         
      then mgu ((avec, Unit, phis)::cs) sigma
      else
        if L.fresh a avec andalso L.fresh b avec       
            then mgu (Constraint.subst [(b,a)] ((avec, Unit, phis)::cs))
                     (composeSubst sigma (b,a))
            else Either.LEFT "Either name is restricted"                
    | mgu _ _ = Err.undefined "Pi.mgu"

  fun solve cs =
    case mgu cs [] of
         Either.RIGHT sigma => Either.RIGHT (sigma, Unit)
       | Either.LEFT msg    => Either.LEFT  msg

  structure BisimConstraint = SymBisimConstraint(PsiPiInstance)

  local open BisimConstraint in


  (* In the pi-calculus instance, the forall constraints are of the following
   * structure:
   *    forall a' . ({|a = a'|} /\ C => {|a = a'|} /\ {|b = a'|} /\ C')
   *
   * which is generated by either input or output actions, for example the above
   * generated by
   *
   * 'a<x> ~ 'b<x> since
   *
   * 'a<x> --y<x>--{|a = y|}--> 0 and
   * 'b<x> --z<x>--{|b = z|}--> 0
   *
   * Obviously, the quantifier elimination is simply replacing all occurences of a'
   * with a in the conclusion and removing {|a=a'|} constraint from the premise.
   * However, the term rewriting rule below is implemented slightly differently:
   * it first finds the required equation, produces a singleton substitution sequence and
   * then substitutes that in the entire implication (producing trivial equation).
   *)
  val forallEliminationRules =
    (fn (Forall (x, Imp(c,c'))) =>
        (let
          fun findE (Atomic (avec, psi, Eq (a,b))) =
                if not (Lst.member x avec) then
                    (if x = a then [(x,b)] else
                     if x = b then [(x,a)] else [])
                else []
            | findE (TermEq (a,b)) =
                if x = a then [(x,b)]
                else if x = b then [(x,a)]
                else []
            | findE (Conj (c,c')) = findE c @ findE c'
            | findE (Disj (c,c')) = findE c @ findE c'
            | findE (Imp  (c,c')) = findE c @ findE c'
            | findE _ = []
        in
          SOME (subst (Imp (c,c')) (findE c))
        end)
       | _ => NONE) :: 

    (fn (Forall (x, True)) => SOME True
      | _ => NONE) ::
       
       []

  val trivialConditionRules =
    (fn (StImp (psi,psi')) => SOME True
      | _ => NONE) ::

    (fn (Atomic (avec, unit, T)) => SOME True
      | _ => NONE) ::

    (fn (Atomic (avec, unit, F)) => SOME False
      | _ => NONE) ::

    (fn (Atomic (avec, unit, Eq (a, b))) =>
        if a = b then SOME True else NONE
      | _ => NONE) ::

    (fn (TermEq (a, b)) =>
        if a = b then SOME True else NONE
      | _ => NONE) ::

    (fn (Atomic (avec, unit, Eq (a, b))) =>
        if a <> b andalso
          (Lst.member a avec orelse Lst.member b avec)
            then SOME False else NONE
      | _ => NONE) ::

    (fn (Atomic ([], unit, Eq(a,b))) => SOME (TermEq (a,b))
      | _ => NONE) ::

    (fn (Atomic ((avec as (n::ns)), unit, Eq (a,b))) =>
        if L.fresh a avec andalso L.fresh b avec
            then SOME (Atomic ([], unit, Eq(a,b)))
            else NONE
      | _ => NONE) ::

    []

  fun freshnessRule c =
    (fn (FreshP (a,p)) =>
        if BisimConstraint.fresh a c then SOME True
        else NONE
     | _ => NONE) :: []

  fun isLiteral (FreshP _)              = true
    | isLiteral (Imp (FreshP _, False)) = true
    | isLiteral (TermEq _)              = true
    | isLiteral (Imp (TermEq _, False)) = true
    | isLiteral _                       = false

  fun eqClosure' ids =
  let
    (* a tuple membership testing in a list *)
    fun eqInClosure (a,b) ids =
      Lst.exists (fn id => id = (a,b)) ids

    (* symmetry *)
    val r = map (fn (a,b) => (b,a)) ids
    val r = List.filter (fn (a,b) =>
                           not (eqInClosure (a,b) ids)) r
    val r = ids @ r

    (* transitivity *)
    val t = map (fn (a,b) =>
                map (fn (_,c) => (a,c))
                    (List.filter (fn (b',c) => b = b') r)) r
    val t = List.concat t
    val t = List.filter
              (fn (a,b) => not (eqInClosure (a,b) r)) t
  in
    if null t
        then r
        else eqClosure' (r @ t)
  end

  fun eqClosure m =
  let
    val (eq,m') = Either.partition
        (map (fn c =>
                case c of
                     TermEq _ => Either.LEFT c
                   | _ => Either.RIGHT c ) m)
    val eqT = map (fn (TermEq eq) => eq
                    | _ => Err.undefined "Pi.eqClosure") eq
    val eqCl = eqClosure' eqT
    val eq' = map (fn eq => TermEq eq) eqCl
  in
    eq @ m'
  end

  fun lEq l l' =
    case (l, l') of
         (TermEq (a,b), TermEq (a',b')) =>
            (a = a' andalso b = b') orelse
            (a = b' andalso b = a')
       | (Imp(TermEq (a ,b ), False),
          Imp(TermEq (a',b'), False)) =>
            (a = a' andalso b = b') orelse
            (a = b' andalso b = a')
       | (FreshP(a,p), FreshP(b,q)) => a = b andalso
                                       Psi.eqData(p,q)
       | (Imp(FreshP(a,p),False),
          Imp(FreshP(b,q),False)) => a = b andalso
                                     Psi.eqData(p,q)
       | _ => false

  fun inM l m = Lst.exists (fn l' => lEq l l') m

  fun negL (Imp (c, False)) = c
    | negL c = (Imp (c, False))

  fun extendM m (l as TermEq (a,b)) =
  let
    val meq = eqClosure (l::m)
    val fr  = List.concat
        (map (fn (FreshP (a,_)) => [a] | _ => []) meq)
  in
    if Lst.exists
        (fn (TermEq (c,d)) => Lst.member c fr
                              andalso Lst.member d fr
          | _ => false) meq
     then NONE
     else
       if Lst.exists
            (fn (ell as TermEq (a,b)) => inM (negL ell) meq
              | _ => false) meq
         then NONE
         else SOME meq
  end
    | extendM m (l as Imp(TermEq(a,b), False)) = SOME (l::m)
    | extendM m (l as FreshP (a,_)) =
        if Lst.exists (fn (FreshP (b,_)) =>
            inM (TermEq (a,b)) m  | _ => false) m
        then NONE
        else SOME (l::m)
    | extendM m (l as (Imp (FreshP _, False))) = SOME (l::m)
    | extendM m False = NONE
    | extendM _ x = (PolyML.print x; Err.undefined "Pi.extendM")

  fun modelRules m =
    [fn l =>
        if isLiteral l then
          if inM l m then SOME True
          else if inM (negL l) m then SOME False
          else NONE
        else NONE]

  fun simpM m c =
    rewrite (simplificationRules @ modelRules m) c

  fun disjToList (Disj (c,c')) = disjToList c @ disjToList c'
    | disjToList c = [c]

  fun cnfToList (Conj (c,c')) = cnfToList c @ cnfToList c'
    | cnfToList c = [disjToList c]

  fun simpClause m c =
    disjToList (simpM m (disjunct c))

  fun simpCNF m c =
    cnfToList (simpM m (conjunct (map disjunct c)))

  fun modelSubst m = modelSubst' m []
  and modelSubst' [] sigma = sigma
    | modelSubst' (TermEq(a,b)::eqs) sigma =
        modelSubst'
            (map (fn e => BisimConstraint.subst e [(a,b)]) eqs)
            (composeSubst sigma (a,b))
    | modelSubst' (_::eqs) sigma = modelSubst' eqs sigma

  fun orientM m =
  let
    val fr =
      List.concat (map (fn (FreshP (a,_)) => [a] | _ => []) m)
    val eq =
      List.filter (fn (TermEq (a,_)) => not (Lst.member a fr)
                    | _ => false) m
  in
    eq
  end

  fun modelsNegC m c =
    case simpClause m c of
         [False] => true
       | _       => false

  fun pureLit m [] = NONE
    | pureLit m (c::cnf) =
    case
      List.find
        (fn l => not (inM l m) andalso
            Lst.all (fn c => not (inC (negL l) c)) cnf) c
      of NONE => pureLit m cnf
       | SOME l => SOME l

  and inC l c = Lst.exists (fn l' => lEq l l') c

  fun unitProp m [] = NONE
    | unitProp m (cl::cnf) =
    case
      List.find
        (fn (l,c) => (not (inM l m)) andalso modelsNegC m c)
        (splitL cl)
      of NONE => unitProp m cnf
       | SOME (l,_) => SOME l

  and splitL' [] pls = []
    | splitL' (l::ls) pls =
        (l, pls @ ls) :: splitL' ls (pls @ [l])
  and splitL ls = splitL' ls []

  fun extendAndDpll m l cnf =
    case extendM m l of
         NONE => NONE
       | SOME m => dpllSAT m cnf

  and splitDpll m l cnf =
    case extendAndDpll m l cnf of
         SOME m => SOME m
       | NONE   => extendAndDpll m (negL l) cnf

  and dpllSAT m [] = validateAndReturn m
    | dpllSAT m (cnf as (c::cs)) =
  let
    val cnf' = simpCNF m cnf
  in
    case cnf' of
         [[True]] => validateAndReturn m
       | _ => (
    case unitProp m cnf' of
         SOME l => extendAndDpll m l cnf'
       | NONE =>
         (case pureLit m cnf' of
               SOME l => extendAndDpll m l cnf'
             | NONE =>
               let
                 val l = hd c
               in
                 splitDpll m l cnf'
               end) )
  end

  and validateAndReturn m =
  let
    val sigma = modelSubst (orientM m)
  in
    if
      Lst.all (
          fn (FreshP (a,p)) => Psi.fresh a (Psi.subst p sigma)
           | (Imp (FreshP (a,p), False)) =>
               not (Psi.fresh a (Psi.subst p sigma)) orelse
               Lst.member a (dom sigma)
           | _ => true
      ) m
    then SOME sigma
    else NONE
  end

  fun solveBisim' c =
  let
    val c    = rewrite ( trivialConditionRules
                       @ simplificationRules
                       @ forallEliminationRules) c
    val c    = rewrite (freshnessRule c) c
    val c    = rewrite forallEliminationRules c
    val c    = cnf c
    val cnf  = cnfToList c
    val sol  = dpllSAT [] cnf
  in
    case sol of
         NONE => Either.LEFT "Unsat"
       | SOME sigma => Either.RIGHT (sigma,unit)
  end

  val solveBisim = SOME solveBisim'

  end

end;

structure SymbolicInstance : SYMBOLIC_PSI = struct
  structure Psi         = PsiPiInstance
  structure Clause      = PsiClause(Psi)
  structure ClEnv       = PsiClauseEnvironment(Clause)
  structure PsiInstance = PsiPiInstance.Inst
  structure Constraint  = PiSymbolicInstanceRequirements.Constraint
  val var               = PiSymbolicInstanceRequirements.var
end


structure SymbolicConstraintSolver : SYMBOLIC_CONSTRAINT_SOLVER =
struct
  structure Inst       = PsiPiInstance.Inst
  structure Constraint = PiSymbolicInstanceRequirements.Constraint
  type solution = (string , (Inst.name * Inst.term) list * Inst.assertion) Either.either
  val solve            = PiSymbolicInstanceRequirements.solve
end;

structure SymbolicBisimConstraintSolver : SYMBOLIC_BISIM_CONSTRAINT_SOLVER =
struct
  structure Psi = PsiPiInstance
  structure Constraint = PiSymbolicInstanceRequirements.BisimConstraint
  val solve =
    case PiSymbolicInstanceRequirements.solveBisim of
         NONE => (fn _ => Either.LEFT "")
       | SOME s => s
end;

structure PiParserPrinterRequirements =
struct

  open PiInstanceRequirements

  fun printN a = a
  fun printT a = a
  fun printC (Eq (a, b)) = a ^ " = " ^ b
    | printC  T = "T"
    | printC  F = "F"
  fun printA psi = "1"

  structure Parser = Parser(StringStream)

  structure Lex = PsiLexerParserComb(Parser)

  fun p >>= q = Parser.>>= (p,q)
  fun p >>  q = Parser.>>  (p,q)

  val name = Lex.identifier

  val condEq =  name >>=
    (fn a =>    Lex.stok "=" >>
                name >>=
    (fn b =>    Parser.return (Eq (a,b))
    ))

  val condT = Lex.stok "T" >> Parser.return T

  val cond = Parser.choice (condT, condEq)

  val assr = Lex.stok "1" >> Parser.return Unit

  fun parseResult p s =
    case Parser.parse p (StringStream.make s) of
         Either.RIGHT (r,s) => Either.RIGHT r
       | Either.LEFT  _ => Either.LEFT "Error parsing"

  fun parseName s = parseResult name s
  fun parseTerm s = parseName s
  fun parseCond s = parseResult cond s
  fun parseAssr s = parseResult assr s

end;

structure PiParserRequirements : PSI_PARSER_REQ =
struct
  structure Psi = PsiPiInstance
  open PiParserPrinterRequirements
  val var = SOME PiSymbolicInstanceRequirements.var
end;

structure PiPrinterRequirements : PSI_PP_REQ =
struct
  structure Inst = PsiPiInstance.Inst
  open PiParserPrinterRequirements
  val var = SOME PiSymbolicInstanceRequirements.var
end;

structure PiCommand = CommandParser(struct
  structure SI           = SymbolicInstance
  structure SCS          = SymbolicConstraintSolver
  structure SBCS         = SymbolicBisimConstraintSolver
  structure PsiParserReq = PiParserRequirements
  structure PPInst       = PiPrinterRequirements
  val useBisim           = true
end);


structure Pi = PiCommand;
structure PsiInstance = Pi;

val start = Pi.start;

